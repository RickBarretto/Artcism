;; author: « RickBarretto
;; year: 2025
;; licence: « MIT
;; version: 1.0.0
;; repository: « https://github.com/RickBarretto/artcism
;;
;; warning: {
;;    Never import this as lean, or this will break the whole code.
;;    At least, for now. This may change in future updates.
;; }

import.version: 3.0.0 {unitt}!

exercism: store.json ~"results.json"

unittIt: new 'it
unittTest: new 'test


it: $[description :string testCase :block][
    ;; wraps unitt's `it` behavior

    ; erases the test case if this must be skipped
    ; basically the same as run an empty block.
    if attr 'skip -> testCase: []

    __assertions: []

    __exercism: #[
        name: description
        output: ""
        test_code: express testCase
    ]

    expects: $[condition :block][
        ; It's internal function to be used inside the testCase block.

        ; The injected function wrapped into a block that will evaluate the expression.
        ; This function is injected by using: .be:, .to: or .to.be:
        __fn: @[attr 'with attr 'to attr 'be ] | filter => null?

        ; If there is a function to be applied
        ; this keyword will be put into the condition block.
        if not? empty? __fn -> 
            condition: prepend condition @[to :word last __fn]
        
        ; Then appends the this assertion into the internal assertion list.
        '__assertions ++ @[condition]
    ]

    debug: $[value :any][
        __format: (attr 'fmt) ?? express value
        __buffer: ~"|__format| |type value|\n"

        __exercism\output: truncate (__exercism\output ++ __buffer) 500

        new value
    ]

    ; Alternative alias for the `expects` function.
    assert: var 'expects

    error: try [do testCase]

    __assertionsStatus: map __assertions '__assertion [
         @[_repr __assertion, equal? @__assertion @[true]]
    ]

    __exercism\status: (last __assertionsStatus)? -> "pass" -> "fail"
    __exercism\message: (first __assertionsStatus)

    if error? error [
        exercism\status: "error"
        exercism\message: to :string error

        ensure.that: "Rule #9: status: is `error' for uncaught exception" 
            ->  "error" = exercism\status
        ensure.that: "Rule #9: message: displays uncaught exception"
            -> (to :string error) = exercism\message
    ]

    if empty? testCase [
        exercism\status: "error"
        exercism\message: "Empty test or skipped."

        ensure.that: "Rule #9: status: is `error' for skipped tests" 
            ->  "error" = exercism\status
        ensure.that: "Rule #9: message: displays reason"
            -> or? in? "empty" lower exercism\message
                   in? "skipped" lower exercism\message
    ]

    if "failed" = __exercism\status [
        exercism\status: "fail"
    ]

    ensure.that: "Rule #7: name: must be human-readable"
        -> description = __exercism\name

    ensure.that: "Rule #8: test_code: must be testCase"
        -> __exercism\test_code = express testCase

    ensure.that: "Rule #9: status: must be valid"
        -> in? __exercism\status ["fail" "pass" "error"]

    ensure.that: "Rule #12: must have :message"
        -> string? __exercism\message

    exercism\tests: exercism\tests ++ __exercism

]

; Alternative alias for the `it` function.
test: var 'it